## Lookup

Lookupモジュールは、リソースに保存されている静的なルックアップテーブルから、データのエンリッチメントや変換を行うために使用されます。1つ以上の*列挙された値*の内容は、*match列*の値と比較され、一致するものが見つかると、その行の*extract列*の値が別の列挙された値に抽出されます：

```
lookup -r <resource name> <enumerated value> <column to match> <column to extract> as <valuename>
```

注意: 構文に加えて ``as <valuename>`` を指定しなかった場合、lookup は「抽出する」カラムの名前を持つ列挙型の値を作成します。

また、マッチするたびに複数のカラムを抽出することもできます。次の例では、列挙値Aの内容をB列の値と照合し、一致した場合にはC列とD列の両方を抽出します：

```
lookup -r mytable A B (C as foo D as bar)
```

Lookupはベクターマッチもサポートしています。つまり、列のセットに対して列挙された値のセットをマッチさせることができます。 ベクターマッチは、マッチリストと抽出リストを指定して実行されます。 ベクトルマッチを実行する場合、抽出された列挙値の数は、マッチする列の数と一致する必要があります。

```
lookup -r mytable [A B] [A B] (C as foo D as bar)
```

### サポートされるオプション
* `-r <arg>`: "r"オプションは、データを強化するためにどのルックアップリソースを使用すべきかをルックアップモジュールに通知します。
* `-s`: "s"オプションは、ルックアップモジュールがすべての抽出が成功することを要求するか、またはエントリが削除されることを指定します。
* `-v`: "v"フラグは、ルックアップモジュールのフローロジックを反転させる。つまり、成功したマッチは抑制され、失敗したマッチは引き継がれる。 "v"フラグと"-s"フラグを組み合わせることで、指定したルックアップテーブルに存在しない値のみを渡す、基本的なホワイトリストを提供することができます。

注意: `-s` または `-v` フラグを使用する際に、抽出を行わないように指定することは合法です。 この操作は、ホワイトリストやブラックリストを作成するときに便利です。

ここでは、列 `X` と `Y` に列挙型の値 `A` と `B` が存在することを保証するが、データの拡張は行わない例を示します。

```
lookup -v -r mytable [A B] [X Y] ()
```

### ルックアップデータリソースの設定

検索結果のデータは、互換性のあるレンダリングモジュール（tableモジュールなど）からダウンロードし、リソースに保存して共有・利用することができます。検索結果ページのメニューで「LOOKUPDATA」を選択すると、この形式で検索結果の表をダウンロードすることができます。

![Lookupダウンロード](lookup-download.png)

[テーブルレンダラ](#!search/table/table.md)には、`-save`オプションもあり、検索結果のテーブルを自動的にリソースとして保存し、後でルックアップで利用できるようにします：

```
tag=syslog regex "DHCPACK on (?P<ip>\S+) to (?P<mac>\S+)" | unique ip mac | table -save ip2mac ip mac
```

上記の例では、テーブルレンダラーは、DHCPログから得られたIPアドレスとMACアドレスのマッピングを含む「ip2mac」というリソースを自動的に作成します。

#### CSVテーブル

ルックアップモジュールではCSVデータも使用できます。Gravwellの検索モジュールでCSVファイルをリソースとして使用するには、CSVファイルに列ごとのユニークなヘッダーが含まれている必要があります。

### 例

#### 基本的な抽出方法

今回の例では、以下のようなcsvから作成された「macresolution」というリソースがあります:

```
mac,hostname
mobile-device-1,40:b0:fa:d7:af:01
desktop-1,64:bc:0c:87:bc:71
mobile-device-2,40:b0:fa:d7:ae:02
desktop-2,64:bc:0c:87:9a:11
```

次に、パケットデータから検索を行い、ルックアップモジュールを使用して、データストリームにホスト名を含めるようにします:

```
tag=pcap packet eth.SrcMAC | count by SrcMAC | lookup -r macresolution SrcMAC mac hostname as devicename |  table SrcMAC devicename count
```

この結果、次のような内容のテーブルができます:

```
64:bc:0c:87:bc:71	|	desktop-1       	|	52183
40:b0:fa:d7:ae:02	|	mobile-device-2 	|	21278
64:bc:0c:87:9a:11	|	desktop-2       	|	 2901
40:b0:fa:d7:af:01	|	mobile-device-1 	|	  927
```

#### ホワイトリスト

上記の「macresolution」テーブルと同じものを使用します:

```
tag=pcap packet eth.SrcMAC | count by SrcMAC | lookup -v -s -r macresolution SrcMAC mac hostname |  table SrcMAC count
```

この結果、ルックアップリストに含まれていないマックアドレスがテーブルに表示されます。 システム管理者は、「-v」および「-s」フラグを使用して、ネットワーク上の新しいデバイスや、イベントストリームの新しいログの基本的なホワイトリストと識別を行うことができます:

```
64:bc:0c:87:bc:60	|	24382
40:b0:fa:d7:ae:13	|	93485
64:bc:0c:87:9a:02	|	11239
40:b0:fa:d7:af:fe	|	   21
```

#### 多重抽出

次のような「places」という名前のルックアップテーブルを考えてみましょう:

```
name,lat,long
Albuquerque,35.122,-106.553
Santa Fe,35.6682,-105.96
Sacramento,38.527,-121.347
```

都市名を指定すると、緯度と経度の両方の値を抽出できるようにしたいと考えています。City "フィールドを含むJSONエントリを扱う場合、以下のクエリはまさにそれを実行します:

```
tag=default json City | lookup -r places City name (lat long) | table
```

列挙された値Cityをテーブルの "name "列と照合し、一致したものがあれば、以下のように "lat "と "long "の両方を抽出します:

![](city.png)
