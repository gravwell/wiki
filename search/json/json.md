# JSON

jsonモジュールは、後で使用するために列挙値に変換する検索エントリのデータを抽出しフィルタリングするために使用されます。 JSONは、データが自己記述的であるため、動的な探索に適したデータ形式です。 JSONモジュールでは、アイテムを抽出して名前を変更したり、抽出された値に基づいてフィルタリングしたりできます。 JSONモジュール内で直接フィルタリングを行うことで、特定のフォーマットのデータを非常に高速かつ直感的に選択することができます。

## サポートされているオプション

* `-e <arg>`: "-e" オプションはレコード全体ではなく、列挙値に対して操作します。
* `-s`: "-s" オプションは、厳密なモードであることをjsonモジュールに通知します。`json -s foo` と指定すると、"foo" という名前のフィールドを含まないエントリはすべて削除されます。逆に、`json foo` は可能な限り単に "foo" を抽出し、何も削除しません。`json -s foo bar` を指定すると、各エントリは "foo" と "bar" という名前のフィールドを含まなければならないことを意味します。
* `-x <arg>`: "-x"オプションは、JSON配列の内容を、配列の値ごとに複数のエントリに展開することを示します。 エントリの残りの部分は同じままです。引数には、現在の抽出物の1つの出力名を指定することも、列挙値を指定することもできます。 したがって、`tag=foo json -x bar foo.bar` と `tag=foo json foo.bar | json -x bar` の両方が有効な起動方法です。

## フィルタリング演算子

JSONモジュールでは、等値性に基づくフィルタリングが可能です。 等値性（"等しい"または"等しくない"）を指定するフィルタが有効な場合、フィルタの指定に失敗したエントリは完全に削除されます。 

| 演算子 | 名前 | 説明 |
|----------|------|-------------|
| == | 等しい  | フィールドは等しい|
| != | 等しくない | フィールドは等しくない|
| ~  | 含む | フィールドはその値を含む|
| !~ | 含まない | フィールドはその値を含まない|

注意 : フィールドが"!="ではなく、フィールドが存在しないと指定された場合、フィールドは抽出されませんが、エントリは削除されません。フィールドを全く含まないエントリを削除したい場合は `-s` フラグを使ってください。

## 例
最も多く投稿しているredditt投稿者を見つけるために、以下の検索は各reddit投稿の "Author"フィールドを新しい列挙値に抽出し、各投稿者の出現回数をカウントしてテーブルに格納します:

```
tag=reddit json Author | count by Author | table Author count
```

また、このモジュールはJSONエントリに複数のレイヤーを降順させることもできます。例えば、テストのためにインジェストするShodanのデータでは、エントリーから"region code"を抽出して、エンドポイントがどこに存在するかを発見することができます。AT&T U-verseの顧客が最も多い州を知りたい場合は、以下のように検索することができます:

```
tag=shodan grep "AT&T U-verse" | json location.region_code | count by region_code | table region_code count
```

### 列挙値の使用

また、必要に応じて、エントリーデータ全体ではなく、列挙値を操作することもできます。例えば、XMLエントリーにjsonが含まれている場合は:

```
<System><Data>{ "domain": "gravwell.io" }</Data></System>
```

次のコマンドを使ってXML内のJSONを "Data"という名前の列挙値として抽出し、jsonモジュールを適用してドメインの値を "domain"という名前の別の列挙値に解析します:

```
xml System.Data | json -e Data domain
```

### 抽出物のリネーム

列挙値の名前は、JSON仕様の最後の名前によって導き出されます。前述の例では、region_codeフィールドを抽出すると、"region_code"という列挙値が出力されます。 出力される列挙値の名前は、"as"引数で上書きすることができます。 次の例では、Data 列挙値からドメイン・メンバを抽出し、それを "dd" という名前の新しい列挙値に割り当てています:

```
json -e Data domain as dd
```
フィルタ演算子を使用すると、Dataフィールドを抽出することができますが、ドメインが値 "google.com"ではない場合に限ります。フィルタはリネームと組み合わせることができます。

```
json -e Data domain != "google.com" as dd
```

### 引用のルール

JSONフォーマットは非常に自由度が高く、SolitonNKが通常セパレータとして扱う"."や"-"などの文字を含む、あらゆるタイプの名前を許容します。JSON名にそのような文字が含まれている場合は、個々のフィールドをダブルクオートで囲み、1つのトークンとして解析します。例えば、次のJSON文字列はフィールド名にドット文字を含んでいます:

```
{ "subfield.op": "stuff", "subfield.type": "int", "subfield.value": 99}
```

subfield.opのメンバーを抽出するjsonモジュールの引数の例は次のようになります:

```
json "subfield.op" as sop
```

同様に、次のような入れ子構造を考えてみます:

```
{ "fields": { "search-id": 1234, "search-type": "background" } }
```

search-idとsearch-typeにはダッシュ文字が含まれているため、これらを使用する場合は引用符("")で囲む必要があります:

```
json fields."search-id" fields."search-type" as type | count by "search-id",type | table "search-id" type count
```

### 配列

jsonモジュールは、配列から要素を抽出することができます。次のような構造を考えてみます:

```
{ "uid": 1, "groups": [17,3] }
```

グループの配列から最初のグループを抽出するには:

```
json groups.[0] as gid
```

(抽出をリネームしないと、列挙値は"[0]"という名前になりますが、これは非常に不格好です)

配列を展開するには、配列を抽出し、出力名を `-x` フラグに渡します:

```
json -x groups groups uid
```

これにより、1つのエントリーが、列挙値が `uid=1` と `groups=17` のものと、 `uid=1` と `groups=3` のものと、2つのエントリーになります。

注意: `-x` フラグで配列を展開すると、基礎となる Data フィールドと他のすべての列挙値はそのまま複製され、配列の列挙値のコンテンツのみが変更されます。

配列の要素の中からコンポーネントを抽出することもできます:

```
{ "Metadata": [ {"Value": "john"}, {"Value": "Albuquerque"} ] }
```

```
json Metadata.[0].Value as Username
```


## 空のフィールドと厳密なフラグ

このモジュールでは、定義されていないフィールドと空の文字列を含むフィールドを区別しています。以下のエントリを考えてます:

```
{"A": "B", "FOO": ""}
```

```
{"A": "Z"}
```

最初のエントリには、空の文字列である"FOO"というフィールドが含まれています。2つ目のエントリには、"FOO "フィールドはありません。

このクエリは最初のエントリを削除して、2つ目のエントリを渡します:

```
json FOO!=""
```

![](foo1.png)

次のクエリは、2つ目のエントリを削除しますが、最初のエントリを通過させ、空の文字列をFOOという名前の列挙値に抽出します:

```
json -s FOO
```

![](foo2.png)

このクエリは両方のエントリを渡し、最初のエントリからFOOを抽出します:

```
json FOO
```

![](foo3.png)

このクエリは両方のエントリを削除します。なぜならば、!=フィルターは最初のエントリを除外し、strictフラグは2つ目のエントリを除外するからです(FOOという名前のフィールドがないからです):

```
json -s FOO!=""
```
