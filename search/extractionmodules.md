# 検索抽出モジュール

Gravwell は structure-on-read のデータレイクであり、これらはその structure を追加するモジュールです。データに関する情報を収集前に知る必要がないため、プラットフォームのパワーと柔軟性が発揮されます。その代わりに、生データをインジェストして、検索時に抽出を行うことができるので、検索操作に圧倒的な柔軟性を与えてくれます。

抽出モジュールは検索の最初のモジュールであることが多いです。例えばネットフローデータは、ネイティブのバイナリ形式でディスク上にあり、そのデータを操作しようとする検索では、抽出と基本的なフィルタリングを行うために、分析パイプラインの最初のモジュールとしてネットフロー抽出モジュールを使用します。`netflow` 抽出モジュールの前に、`grep` のようなモジュールを使ってフィルタリングを行うことは*可能*ですが、それは効果的ではないでしょう。

検索抽出モジュールは、検索パイプラインの残りの部分を通して、生データと"一緒"に検索されるデータからフィールドを抽出します。抽出されたデータ/フィールド/プロパティは、パイプライン内の次のモジュールが使用するためのエントリと一緒に存在する列挙値になります。例えば、モジュールシーケンス `netflow Src | subnet Src /16 as srcsub | grep -e srcsub "10.1.0.0.0"` を使用した検索は、生のネットフローレコードから Src IP アドレスを抽出し、Src IP アドレスから /16 サブネットを抽出し、その後 grep を使用して抽出されたサブネットに基づいてフィルタリングします。この例では、生データは"Src"と"srcsub"列挙値と同様にgrepモジュールで利用可能です。

## クエリ・アクセラレータ

抽出モジュールは、あるモジュールでフィルタリングが使用されている場合、[クエリ・アクセラレータ](configuration/accelerators.md) (フルテキストインデックス、JSONインデックスなど)を利用することができます。例えば、モジュール `netflow Src Dst Port==22` を使用すると、適切に設定されたアクセラレータを使用して検索時間を劇的に短縮することができます。

いくつかの処理モジュール（[words](words/words.md)など）は、加速インデックスに対するフィルタリングを直接行います。

## ユニバーサル・フラグ

いくつかのフラグは、いくつかの異なる検索モジュールに表示され、全体を通して同じ意味を持ちます:

* `-e <source name>` は、モジュールがエントリのデータフィールドからではなく、与えられた列挙値から入力データを読み取るように指定します。これは、[json](json/json.md)のようなモジュールで、JSONエンコードされたデータがより大きなデータレコードから抽出されている場合に便利です。例えば、以下の検索では、HTTPパケットのペイロードからJSONフィールドを読み取ろうとします: `tag=pcap packet tcp.Payload | json -e Payload user.email`
* `-r <resource name>` は、[resources](#!resources/resources.md)システムのリソースを指定します。これは一般的に、[geoip](geoip/geoip.md)モジュールが使用するGeoIPマッピングテーブルのように、モジュールが使用する追加データを格納するために使用されます。
* `-v`は、通常の通過/削除のロジックを反転させることを意味します。例えば、[grep](grep/grep.md)モジュールは、通常、与えられたパターンに一致したエントリを通過させ、一致しないエントリを削除しますが、`-v`フラグを指定すると、一致したエントリを削除し、一致しないエントリを通過させます。
* `-s`は"厳密"モードを示します。モジュールが通常、いくつかの条件のうちどれかひとつが満たされていれば、エントリをパイプラインで進めることができる場合、strict フラグを設定すると、*すべての*条件が満たされている場合にのみエントリーを進めることができます。たとえば、[require](require/require.md)モジュールは、通常は、必要な列挙値のいずれかが含まれていればエントリーを通過させますが、`-s`フラグが使用されると、指定された列挙値が*すべて*含まれているエントリーのみを通過させます。
* `-p`は"許可"モードを示します。 パターンやフィルタが一致しないときに、通常モジュールがエントリを削除する場合、permissive フラグはモジュールを通すように指示します。 [regex](regex/regex.md)モジュールや [grok](grok/grok.md)モジュールは、この permissive フラグが有効な例です。

## ユニバーサルな列挙値

以下の列挙値は、すべてのエントリで利用可能です。これらは実際には、生のエントリ自体のプロパティの便利な名前ですが、列挙値の名前として扱うことができます。

* SRC -- エントリデータのソース
* TAG -- エントリに添付されているタグ
* TIMESTAMP -- エントリのタイムスタンプ
* DATA -- 実際のエントリデータ
* NOW -- 現在の時刻

これらは、ユーザー定義の列挙値と同じように使用できるので、`table foo bar DATA NOW`は有効です。これらは、どこかに明示的に *抽出* する必要はなく、常に利用可能です。

## モジュールのドキュメント

注意：ここに記載されているモジュールは、抽出の主な機能を持っています。また、フィルタリングや処理を行うこともできます。

* [ax](ax/ax.md)
* [canbus](canbus/canbus.md)
* [cef](cef/cef.md)
* [csv](csv/csv.md)
* [dump](dump/dump.md)
* [fields](fields/fields.md)
* [grok](grok/grok.md)
* [ip](ip/ip.md)
* [ipfix](ipfix/ipfix.md)
* [j1939](j1939/j1939.md)
* [json](json/json.md)
* [kv](kv/kv.md)
* [namedfields](namedfields/namedfields.md)
* [netflow](netflow/netflow.md)
* [packet](packet/packet.md)
* [packetlayer](packetlayer/packetlayer.md)
* [regex](regex/regex.md)
* [slice](slice/slice.md)
* [strings](strings/strings.md)
* [subnet](subnet/subnet.md)
* [syslog](syslog/syslog.md)
* [winlog](winlog/winlog.md)
* [xml](xml/xml.md)
