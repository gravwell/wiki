## transaction

注意：`transaction` モジュールは大量のメモリを消費する可能性があります。メモリに制約のあるシステムでこのモジュールを使用する場合は注意してください。

`transaction` モジュールは、任意の数のキーに基づいて、パイプライン内のエントリを単一エントリの「トランザクション」（エントリのグループ化）に変換し、グループ化します。これは、データストリームの複数のエントリにまたがる、特定のユーザや IP などのアクティビティをキャプチャするための強力なツールです。

### サポートされているオプション

* `-e`: `-e` オプションは、レコード全体ではなく、列挙値に対して操作を行います。追加の `-e` フラグを提供することで、複数の EV をサポートします。
* `-rsep`: `-rsep` オプションでは、トランザクションレコードの間に挿入する文字列を設定します。デフォルトは "\n" です。
* `-fsep`: `-fsep` オプションは、与えられたレコードの中の列挙値の間に挿入する文字列を設定します。デフォルトは " " です。
* `-o`: `-o` オプションは、生成する出力 EV を設定します。デフォルトは "transaction" です。
* `-c`: `-c` オプションは、指定された名前のトランザクションを構成するエントリの数をカウントすることを可能にします。デフォルトは "count" です。
* `-maxsize`: `-maxsize` フラグは、あるトランザクションがトラッキングテーブルから退避するまでの最大サイズをキロバイト単位で設定します（後述の「メモリに関する考慮事項」を参照）。デフォルトは 500kb です。
* `-maxstate`: `-maxstate` フラグは、追跡するトランザクションの最大数を設定します。これを超えると、最も古いトランザクションが破棄されます（後述の「メモリに関する考察」を参照）。デフォルトは 200 です。

すべてのフラグはオプションです。

### 概要

`transaction` モジュールは、与えられたキーのセットに基づいて、エントリを単一のエントリにグループ化します。例えば、"host"、"message"、"action" という列挙値を持つデータセットが与えられた場合、次のようなクエリを実行します。

```
tag=data kv host action message | transaction -fsep " -- " host | table
```

EV "host" に同じ値を持つすべてのエントリを、ひとつのエントリにまとめます。デフォルトでは、`transaction` は、キーの一部ではないすべての EV を出力にグループ化します。上記の例では、EV "host" と "message" が `-fsep` をセパレータとしてグループ化され、このキーにマッチするすべてのエントリが `-rsep` によってさらにグループ化されます。上記の例を説明するために、次のようなエントリーがあるとします。

```
Entry 1: host="foo" message="Host foo login" action="login"
Entry 2: host="foo" message="Host foo delete file X" action="delete"
Entry 3: host="bar" message="Host bar login" action="login"
Entry 4: host="foo" message="Host foo logout" action="logout"
```

は、"foo" と "bar" の2つのエントリーに分割されます。

```
Entry 1: transaction="login -- Host foo login
                      delete -- Host foo delete file X
                      logout -- Host foo logout"
Entry 2: transaction="login -- Host bar login"
```

グループ化する EV を正確に指定するには、クエリの中で1つ以上の `-e` フラグを使用します。EV は指定された順序でグループ化されます。例えば、以下のようになります。

```
tag=data kv host action message user group | transaction -e action -e message host | table
```

"user" と "group" を無視して、"action" と "message" の EV のみをグループ化します。

複数のキーを指定することができ、指定されたすべてのキーのグループ化に基づいてレコードが作成されます。例えば、以下のようになります。

```
tag=data kv host action message user group | transaction host action user | table
```

同じホスト、アクション、ユーザーを持つレコードをグループ化します。

### メモリに関する考察

トランザクションを作成するためには，`transaction` モジュールがデータストリームのすべてのエントリをバッファリングする必要があります．大量のデータを生成するクエリの場合，これはシステム上の利用可能なメモリをすぐに使い果たしてしまう可能性があります．これを防ぐために、`transaction` モジュールは、`-maxsize` と `-maxstate` という2つのフラグを用意し、パイプラインの下流にデータを渡す前にデータを保持する量と期間を制御します。

実行中、`transaction` モジュールはレコードのテーブルを保持し、提供されたキーのユニークなセットごとに 1 つのレコードを持ちます。あるエントリーが提供されたキーにマッチすると、テーブル内の同じマッチを持つ他のエントリーに追加されます（最初に遭遇した場合は新しいレコードが作成されます）。エントリーがテーブルに追加されるたびに、2つのチェックが行われます。

* 与えられたレコードのサイズが `-maxsize` 引数を超えた場合、そのレコードは直ちに "evict" されます。つまり、クエリパイプラインを通ってテーブルから削除されます。
* レコードの数が `-maxstate` 引数を超えると、最も最近更新されたレコードが消去されます。

レコードが退避され、その後、退避されたレコードと同じキーを持つエントリに遭遇した場合、新しいレコードが作成されます。出力に「断片化」が見られる場合には、`-maxsize` と `-maxstate` フラグをチェックしてください。

`transaction` モジュールは Gravwell システムの利用可能なメモリを簡単に使い切ってしまうので、`transaction` を使ってクエリを書くときは以下の一般的なガイドラインに従ってください。

* `transaction` モジュールは、クエリのできるだけ最後に配置します。
* 最小の時間枠を設定してください。
* 小さな `-maxsize` と `-maxstate` の値で開始し、必要に応じて増やしていきます。
* すべての列挙値をグループ化するのではなく、クエリに関係するものだけをグループ化するために、`-e`と明示的に名前を付けます。
