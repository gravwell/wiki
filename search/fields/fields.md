## Fields

fieldsモジュールは、後で使用するために、検索エントリから列挙値にデータを抽出してフィルタ処理するために使用されます。  fieldsモジュールは、データ項目が一定のバイトセットで区切られている場合に、データをキャプチャしてフィルタ処理する際に非常に柔軟になるように設計されています。  カンマ区切り（CSV）、タブ区切り、スペース区切りの形式は、fieldsモジュールを使用して簡単に処理できます。  マルチバイトの区切り文字や既知のフィールド区切り文字を持つバイナリフォーマット、あるいはその両方を使用したもっと複雑な構造では、フィールドシステムを使用して任意のフィールド境界で抽出できます。  fieldsモジュールの恩恵を受けることができるデータプロデューサーの例は、タブ区切り形式またはsnortからのCSV出力形式を持つ[bro](https://www.bro.org/)です。

数値フィールドオフセットの指定は頻繁に使用すると面倒になることがあるため、namedfieldsモジュールはユーザーがアップロードしたリソースを使用してフィールドインデックスにわかりやすい名前を割り当てます。

### 抽出フィールドの指定

フィールドは、ゼロの基数からデータへのインデックスを指定することによって抽出されます。  インデックスは、角括弧で囲まれた正の整数を使用して指定されます。複数のディレクティブを指定することで複数のフィールドを抽出できます。  フィールド抽出インデックスを順番に指定する必要はありません

抽出されたインデックスフィールドは`as <name>`、フィールドインデックス値の直後にディレクティブを追加することによって名前を変更できます。 たとえば、データから6番目のフィールドを "uri"という名前の列挙値に抽出するには、抽出ディレクティブは次のようになります
`[5] as uri`
名前変更ディレクティブが指定されていない場合、抽出された値にはインデックスと一致する名前が付けられます。  抽出されたフィールドはフィルタをサポートしています。これにより、同等性または含まれている値に基づいてエントリをすばやくフィルタリングできます。  フィルタは、名前変更ステートメントの前に指定する必要があります。  最初のフィールドが値 "stuff"であるところだけでエントリが通過できるようにするfieldsディレクティブの例は以下となります。
`[0]=="stuff"`
1番目のフィールドが "stuff"の値と等しくないエントリのみを許可し、1番目のフィールドの名前を "things"に変更します`[0] != "stuff" as things`。

重要: フィールド抽出索引は、10進数、8進数、または16進数として指定できます。  適用されるデフォルト名は、索引の元のテキスト値です。  [0xA]の抽出ディレクティブは "0xA"という名前の11番目のフィールドを抽出し、[010]は9番目のフィールドを抽出して "010"という名前を適用します。

重要: " - "、 "。"、またはスペースなどの特殊文字を含むフィルター値や抽出名を二重引用符で囲むように指定します。

### サポートされているオプション

* `-e <arg>`: “ -e”オプションは、レコード全体ではなく列挙値に作用します。
* `-d <arg>` : “ -d”オプションは、フィールドの抽出に使用される区切り文字を指定します。  区切り文字は任意のバイト文字列です。デフォルトはカンマ： ","です。
* `-s` :“ -s”オプションは、fieldsモジュールが厳密モードで動作することを指定します。いずれかのフィールド指定を満たすことができない場合、そのエントリは削除されます。例えば、0番目、1番目、2番目のフィールドが欲しいがエントリが2つのフィールドしか持っていない場合、strictフラグはエントリを落とします。
* `-q` : “ -q”オプションは、フィールドを引用符で囲むことができることを指定します。これは、フィールドに現れる可能性のある区切り文字を扱うときに便利です。たとえば、フィールド区切り文字がスペースの場合、列にはスペースを含める必要があり、引用符で囲まれます。"-q"引数を指定した場合、二重引用符で囲まれた区切り文字は無視され、フィールドに含まれます。"-q"フラグを使用する場合、区切り文字に二重引用符を含めることはできません。
-clean注：“ -clean”フラグは、fieldsモジュールが抽出されたフィールドから周囲の空白をすべて削除するように指定します。末尾の空白があるかもしれないCSVのようなデータフォーマットは、無用の空白を削除するために "-clean"フラグを使うことができます。"-q"フラグが "-clean"とともに指定されている場合、二重引用符は引用符付きフィールドから削除されます。


### フィルタリング演算子

fieldsモジュールは同等性に基づくフィルタリングを可能にします。  等価（ "等しい"、 "等しくない"、 "含む"、 "含まない"）を指定するフィルタが有効になっている場合、フィルタの指定に失敗したエントリはすべて削除されます。  フィールドが等しくない "！="として指定され、そのフィールドが存在しない場合、そのフィールドは抽出されませんが、エントリは完全にはドロップされません。

| オペレーター | 名 | 説明 |
|----------|------|-------------|
| == | 等しい | フィールドは等しくなければなりません
| != | 等しくない | フィールドは等しくてはいけませんl
| ~ | サブセット | フィールドに値が含まれています
| !~ | サブセットではない | フィールドに値が含まれていません

### 例

タブ区切りのbro http.logフィードからURLフィールドを抽出し、「url」という名前を付けます。

```
tag=brohttp fields -d "\t" [9] as url
```

タブ区切りのbro http.logフィードからURLおよび要求者フィールドを抽出し、URLにスペースが含まれているエントリーのみをフィルター処理して結果を表に出力します。

```
tag=brohttp fields -d "\t" [9] ~ " " as url [2] as requester | table url requester
```

区切り文字 "|"を使用して4、5、6番目のフィールドを抽出します。そして抽出されたフィールドからきれいな空白を取り除きます。

```
tag=default fields -clean -d "|" [3] [4] [5] | table 3 4 5
```

bro httpログストリームからURIを抽出し、そのURIをパスとPUT引数コンポーネントに分離してから、各パスの引数のエントロピーを計算し、結果をグラフ化します。

```
tag=brohttp fields -d "\t" [9] ~ "?" as uri |  regex -e uri "^(?P<path>[^\?;]+)\?(?P<args>.+)" | entropy args by path | chart entropy by path
```

複数のストリームを持つJPEG構造を持つHTTPパケットを探します（例：メイン画像とサムネイル）

```
tag=pcap packet tcp.Port==80 tcp.Payload | fields -s -e Payload -d "\xd8\xff" [1]~"JFIF"  [2]~"JFIF" | slice 1[0:10] 2[0:10] | table 1, 2
```
