## XML

xmlモジュールは、後で使用するためにXMLデータから列挙値にコンポーネントを抽出できます。  XMLは型指定されていないので、すべての結果は文字列として返されます。

3つのネストされた要素`A`、`B`、および`C`で構成される次のXMLスニペットを考えます。  最も内側の要素`C`には、`MyAttr`という名前の関連属性があります。.

```
<A><B><C MyAttr="foo">bar</C></B></A>
```

`C`の**値**を抽出するには、次のクエリを使用します:

```
xml A.B.C
```

クエリは、結果 "bar"を "C"という名前の列挙値に配置します。

一方、MyAttr属性の値を抽出する場合は、次の構文を使用します:

```
xml A.B.C[MyAttr]
```

これにより、値 "foo"を含む "MyAttr"という名前の列挙値が作成されます。

指定された最後の要素がさらにXML要素を含む場合、モジュールは内部XMLを文字列として返します。:

```
xml A.B
```

returns ```<C MyAttr="foo">bar</C>```.

XML要素は、他のモジュールで使用するのに適した方法で常に命名されているわけではありません。  たとえば、 "My-Element"という名前の要素はevalモジュールを混乱させElementますMy。  そのため、ある変数から別の変数から減算したいと思うでしょう。  xmlモジュールを使用すると、結果の列挙値に別の名前を選択できます:

```
xml A.B.My-Element as MyElement
```

同様に、要素または属性に ".", "[", または "]"の文字が含まれている場合は、その要素を引用符で囲んで、特殊文字が要素名の一部であることをモジュールに知らせることができます:

```
xml A."My.Element" as MyElement
```

### フィルタリング

xmlモジュールは、可能な場合に追加モジュール（evalなど）の呼び出しを回避するために、データの単純な事前フィルタリングを可能にします。  XMLの動作方法のため、xmlモジュールがフィルタリングを処理する方法にはいくつかの特殊性があるため、このセクションを注意深く読むことが重要です

モジュールは、要素の値がリテラル値と等しいかどうかをテストできます。 その場合、要求された要素が抽出され、検索エントリがパイプラインに沿って渡されます。 この検索を検討してください:

```
xml A.B=="foo"
```

次のXMLエントリはテストに合格し、"B"という名前の新しい列挙要素でパイプラインを続行します。:

```
<A><B>foo</B></A>
```

次のエントリでは続行しません:

```
<A><B>bar</B></A>
```

これは多かれ少なかれ直感的です。  ただし、XMLでは同じレベルで複数の子要素を使用できるため、目的のデータを抽出することが非常に困難です。  たとえば、次のようなものがあります。:

```
<System>
	<Data Name="OSVersion">Windows 10</Data>
	<Data Name="Username">gravwell</Data>
</System>
```

`xml System.Data`と言うだけでは、最初の結果"Windows 10"のみが抽出されます。  ユーザー名を抽出するために、**属性**と比較できます。  ただし、xmlモジュールが一致を検出すると、現在の** element **データを抽出します:

```
xml System.Data[Name]=="Username"
```

このクエリの結果、文字列"gravwell"を含む`Data`という名前の新しい列挙値が作成されます。


### ポートされているオプション

* `-e <arg>`: "-e"オプションは、レコード全体ではなく列挙値で動作します。