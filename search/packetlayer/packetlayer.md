## パケットレイヤー

パケットモジュールは、パケット処理に非常に堅牢なインターフェイスを提供していますが、1つの重大な障害があります、それは健全性を期待しています。 パケットプロセッサは、様々な操作を呼び出す際に、パケットを正確に分解するために必要な親レイヤーを継承します。 パケットクエリがtcpポートを要求する場合、パケットプロセッサはtcpレイヤ(イーサネット、802.11q、IPv4、IPv6のいずれか)に到達するために必要なサブレイヤを呼び出します。 パケット層の処理が必要な場合でも、パケットが不正な形式であったり、ラップされていたり、単に破損していたりする場合には、「パケット層」を使用して指定された層だけを処理することができます。

packetlayer モジュールの呼び出しは、packet モジュールと同じですが、最下層のレイヤーが存在する唯一のレイヤーであることを期待しています。 以下に、この機能が役立つと思われるクエリの例を示します。 パケットレイヤーのパーサーは、エントリーや列挙値にデータがある限り、パケットレイヤーを抽出し続けますので、非常に大きなパケットレイヤーの塊を扱うことが可能になります。 netflow パケットのフラットなバイナリファイルを持っていますか？ Packetlayer はそれを扱うことができます。

### サポートされているオプション

* `-e <arg>`: 「-e」オプションは、レコード全体ではなく、列挙値を操作します。例えば、パケット処理エンジンは、レイヤー 2 のトンネルの分析など、抽出された値に対して操作することができます。
* `-m : 「-m」オプションは、データがなくなるまで、指定されたレイヤーを抽出し続けることをパケットレイヤープロセッサーに指示します（マルチエクストラクト）。 このオプションは、レイヤー 4+ のメッセージを抽出するのに便利です。`

### レイヤー 4+ プロトコル抽出

レイヤー3以上のプロトコル・レイヤーはストリーム・ベースで、下位レイヤーにトランスポートを依存していることが多く、複数のレイヤー4+メッセージが単一のレイヤー3ペイロードに含まれていることがよくあります。パケットレイヤープロセッサーを使ってこれらのメッセージを抽出するクエリの例では、tcpレイヤーのペイロードに到達するためにパケットモジュールを使用し、複数のModbusペイロードを抽出するためにパケットレイヤーモジュールを使用します。

```
tag=pcap tcp.Port == 502 tcp.Payload | packetlayer -m -e Payload modbus.Transaction != 0 modbus.Unit | count by Unit | chart count by Unit
```

### ラップされたパケットトランスポートの抽出

時折、ドキュメントのないトランスポートプロトコルに遭遇したり、怒った開発者に手を焼いたりすることがあります。 packetlayer モジュールを使用することで、正気を保つことができます。

```
tag=pcap ipv6.SrcIP udp.Port == 31337 udp.Payload | slice Payload[0:4] as id Payload[4:] as payload2 | packetlayer -e payload2 modbus.Transaction != 0 modbus.Unit | count by Unit | chart count by Unit
```
